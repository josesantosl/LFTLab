#+title: esercizi di esami svolti
* automi a stati finiti
** Dato il DFA, determinare quale delle seguenti stringhe  è accettata da A.
|------+----+----|
|      | 1  | 2  |
|------+----+----|
| q0   | q0 | q0 |
| *q1  | q0 | q0 |
| *q2  | q4 | q5 |
| →*q3 | q0 | q2 |
| q4   | q0 | q1 |
| *q5  | q0 | q5 |
|------+----+----|

- [ ] 22
- [ ] 12
- [ ] 221
- [ ] 122
*** Risposta
#+begin_example
  (2)  (2)
q3 → q2 → q5
#+end_example
- [✓] 22
- [X] 12
- [X] 221
- [X] 122
** Dato il DFA A. Determinare quale delle seguenti stringue è accettata da A.
|------+----+----|
|      | c  | d  |
|------+----+----|
| q0   | q0 | q0 |
| *q1  | q0 | q0 |
| →*q2 | q1 | q4 |
| *q3  | q0 | q4 |
| q4   | q3 | q4 |
|------+----+----|
- [ ] ddcdc
- [ ] ddcc
- [ ] dccdc
- [ ] ddccc
*** Risposta
#+BEGIN_EXAMPLE
  (d)  (d)  (c)  (d)  (c)
q2 → q4 → q4 → q3 → q4 → q3
#+END_EXAMPLE

- [✓] ddcdc
- [X] ddcc
- [X] dccdc
- [X] ddccc
** Dato il DFA A. Determinare quale delle seguenti stringue è accettata da A.
|-----+----+----|
|     | 0  | 1  |
|-----+----+----|
| q0  | q0 | q0 |
| *q1 | q0 | q0 |
| →q2 | q3 | q1 |
| q3  | q2 | q3 |
|-----+----+----|
- [ ] 00101
- [ ] 00000
- [ ] 10001
- [ ] 00001
*** Risposta

q2 →(0) q3 →(0) q2 →(0) q3 →(0) q2 →(1) q1

- [X] 00101
- [X] 00000
- [X] 10001
- [✓] 00001
* Minimizzazione
** minimizza
minimizzare il seguente DFA

|-----+---+---+------------|
|     | 0 | 1 | comento    |
|-----+---+---+------------|
| 0   | 0 | 0 | uguale a 1 |
| *1  | 0 | 0 | uguale a 0 |
| *2  | 3 | 0 | uguale a 3 |
| *3  | 3 | 0 | uguale a 2 |
| 4   | 1 | 0 |            |
| ->5 | 2 | 4 |            |
|-----+---+---+------------|

|--------+-------+-----|
|        | 0     | 1   |
|--------+-------+-----|
| {0}    | {0}   | {0} |
| *{1}   | {0}   | {0} |
| *{2,3} | {2,3} | {0} |
| {4}    | {1}   | {0} |
| ->{5}  | {2,3} | {4} |
|--------+-------+-----|

0| |
1|xx|
2|xx |
3|    |
4|
-------
 |12345

** Definire un'espresione sull'alfabeto {a,b,c} che generi il linguaggio delle stringhe in cui la prima _a_, se presente, è precedutta da un numero dispari di b.
                        (c*) (ϵ + (bb*)(b)(a)) (a+b+c)*

|----+---+---|
|    | 0 | 1 |
|----+---+---|
| 0  | 0 | 0 |
| *1 | 3 | 4 |
| *2 | 2 | 0 |
| *3 | 3 | 0 |
| *4 | 2 | 4 |
|----+---+---|

Data l'espressione regolare E = (bcb +c*)* sull'alfabeto {a,b,c}, determinare quale delle
seguenti stringhe appartiene al linguaggio generato da E.

*** [ ] cbc
*** [ ] bc
*** [ ] cbcbc
*** [ ] bcbcb

** Minimizzare il seguente DFA. Mostrare la _tabella di transizione completa_ del DFA minmo i cui stati sono le classi di equivalenza risultanti dalla minimizzazione, anhe nel caso in cui il DFA sia già minimo.
|-------+---+---|
|       | 0 | 1 |
|-------+---+---|
|     0 | 0 | 0 |
|   * 1 | 3 | 2 |
|     2 | 1 | 1 |
|     3 | 2 | 0 |
| → * 4 | 3 | 2 |
|-------+---+---|
*** Risposta
facendo velocemente vediamo che tanto 1 come 4 hanno le stesse uscite
|-------+---+---|
|       | 0 | 1 |
|-------+---+---|
|   * 1 | 3 | 2 |
| → * 4 | 3 | 2 |
|-------+---+---|
quindi si puo simplificare come
|---------+-------+-------|
|         |     0 |     1 |
|---------+-------+-------|
|       0 |     0 |     0 |
| * {1,4} |     3 |     2 |
|       2 | {1,4} | {1,4} |
|       3 |     2 |     0 |
|---------+-------+-------|

** Minimizzare il seguente DFA. Mostrare la _tabella di transizione completa_ del DFA minmo i cui stati sono le classi di equivalenza risultanti dalla minimizzazione, anhe nel caso in cui il DFA sia già minimo.
|----+---+---|
|    | a | b |
|----+---+---|
| 0  | 0 | 0 |
| *1 | 0 | 0 |
| *2 | 3 | 0 |
| *3 | 3 | 0 |
| 4  | 1 | 0 |
| →5 | 2 | 4 |
|----+---+---|
*** Risposta
la prima cosa che vediamo è che _*2_ e _*3_ sono uguali, allora facciamo l'unione
|--------+-------+---|
|        |     a | b |
|--------+-------+---|
| 0      |     0 | 0 |
| *1     |     0 | 0 |
| *{2,3} | {2,3} | 0 |
| 4      |     1 | 0 |
| →5     | {2,3} | 4 |
|--------+-------+---|
** pagina 21
|-----+---+---|
|     | 0 | 1 |
|-----+---+---|
| 0   | 0 | 0 |
| →*1 | 3 | 4 |
| *2  | 2 | 0 |
| *3  | 3 | 0 |
| *4  | 2 | 4 |
|-----+---+---|
*** Risposta
In questo caso non funziona quello di sempre.
2 e 3 vengono simplificati per essere entrambi recorsivi(una volta che si entra non si esce). volendo anche potrebbe minimizzarlo anche con il 0. ma per qualche
motivo non si ha fatto in nessuna delle risposte, devo chiedere perche.

|--------+-------+---|
|        | 0     | 1 |
|--------+-------+---|
| 0      | 0     | 0 |
| →*1    | {2.3} | 4 |
| *{2,3} | {2,3} | 0 |
| *4     | {2,3} | 1 |
|--------+-------+---|
e ora 1 e 4 vano allo stesso punto con 0 e verso l'altro con 1. quindi anche possiamo simplificarlo.

|---------+-------+-------|
|         | 0     |     1 |
|---------+-------+-------|
| 0       | 0     |     0 |
| →*{1,4} | {2.3} | {1,4} |
| *{2,3}  | {2,3} |     0 |
|---------+-------+-------|

** pagina 30
|----+---+---|
|    | a | b |
|----+---+---|
| 0  | 0 | 0 |
| *1 | 0 | 0 |
| *2 | 1 | 0 |
| 3  | 2 | 3 |
| →4 | 2 | 3 |
|----+---+---|
*** Risposta
3 e 4 si collegano perche entrambi vano verso 2 e 3.

invece 0 e *1 non possono essere collegato perche *1 è uno stato finale.
|--------+---+-------|
|        | a |     b |
|--------+---+-------|
| 0      | 0 |     0 |
| *1     | 0 |     0 |
| *2     | 1 |     0 |
| →{3,4} | 2 | {3,4} |
|--------+---+-------|
* epsilon chiusura
** Detta α la funzione di transizione dell'automa seguente

|------+------+------+---------|
|      | 0    | 1    | ϵ        |
|------+------+------+---------|
| → q0 | ø    | ø    | {q1,q5} |
| q1   | {q2} | ø    | ø       |
| q2   | ø    | ø    | {q3}    |
| q3   | ø    | {q4} | ø       |
| q4   | ø    | ø    | {q1,q5} |
| *q5  | ø    | ø    | ø       |
|------+------+------+---------|

quale dei seguenti insiemi corrisponde a δ(q1,01)?

- [ ] {q1,q2,q5}
- [ ] {q1,q4,q5}
- [ ] {q1,q3,q5}
- [ ] {q1,q4,q5}

*** risposta
q1 →(0) q2 →(ϵ) q3 →(1) q4

allora δ(q1,01) contiene q4 e il ϵ di q4

- [X] {q1,q2,q5}
- [X] {q1,q4,q5}
- [X] {q1,q3,q5}
- [✓] {q1,q4,q5}
** Detta α la funzione di transizione dell'automa seguente
|------+------+------+---------|
|      | c    | d    | ϵ        |
|------+------+------+---------|
| → q0 | {q1} | ø    | ø       |
| q1   | ø    | ø    | {q2}    |
| q2   | ø    | ø    | {q3,q5} |
| q3   | ø    | {q4} | ø       |
| q4   | ø    | ø    | {q3,q5} |
| *q5  | ø    | ø    | ø       |
|------+------+------+---------|

quale dei seguenti insiemi corrisponde a δ(q4,dd)?

- [ ] {q3,q4,q5}
- [ ] {q2,q4,q5}
- [ ] {q0,q4,q5}
- [ ] {q1,q4,q5}

*** Risposta
  (ϵ)  (d)  (ϵ)  (d)
q4 → q3 → q4 → q3 → q4

e il δ(q4) = {q3,q5}∪{q4} = {q3,q4,q5}

- [✓] {q3,q4,q5}
- [X] {q2,q4,q5}
- [X] {q0,q4,q5}
- [X] {q1,q4,q5}

** Detta α la funzione di transizione dell'automa seguente

|------+------+---------|
|      | b    | ϵ        |
|------+------+---------|
| → q0 | ø    | {q1,q5} |
| q1   | {q2} | ø       |
| q2   | ø    | {q3}    |
| q3   | {q4} | ø       |
| q4   | ø    | {q1,q5} |
| *q5  | ø    | ø       |
|------+------+---------|

quale dei seguenti insiemi corrisponde a δ(q4,bb)?

- [ ] {q1,q4,q5}
- [ ] {q1,q3,q5}
- [ ] {q3,q4,q5}
- [ ] {q0,q4,q5}

*** Risposta
#+begin_example
  (ϵ)  (b)  (ϵ)  (b)
q4 → q1 → q2 → q3 → q4
#+end_example
e il δ(q4) = {q1,q5}. quindi δ(q4,bb) = {q1,q4,q5}

- [✓] {q1,q4,q5}
- [X] {q1,q3,q5}
- [X] {q3,q4,q5}
- [X] {q0,q4,q5}

** Detta α la funzione di transizione dell'automa seguente

|------+------+------+---------|
|      | 0    | 1    | ϵ        |
|------+------+------+---------|
| → q0 | ø    | ø    | {q1,q5} |
| q1   | {q2} | ø    | ø       |
| q2   | ø    | ø    | {q3}    |
| q3   | ø    | {q4} | ø       |
| q4   | ø    | ø    | {q1,q5} |
| *q5  | ø    | ø    | ø       |
|------+------+------+---------|

quale dei seguenti insiemi corrisponde a δ(q2,10)?

- [ ] {q2,q4}
- [ ] {q2,q3}
- [ ] {q0,q3}
- [ ] {q1,q3}

*** Risposta
q2 →(ø) q3 →(1) q4 →(ø) q1 →(0) q2
δ(q2) = q2 ∪ {q3} = {q2,q3}

- [X] {q2,q4}
- [✓] {q2,q3}
- [X] {q0,q3}
- [X] {q1,q3}

* Espressioni regolari
** Data l'espressione regolare E=((10)*+1*)* sull alfabeto {0,1,2}, determinare quale delle seguenti string appartiene al linguaggio generato da E.
- [ ] 11000
- [ ] 10110
- [ ] 10010
- [ ] 00
*** risposta
questo caso posso scartare tra questi. considerando che per forza deve avere un
_1_ prima di un _0_, possiamo scartare tutti quelli che hanno piu da un 0 ripetuto.
lasciando all'opzione *10110* come unica valida
- [X] 11000
- [✓] 10110
- [X] 10010
- [X] 00

** Definire un'espressione regolare sull'alfabeto {a,b,c} che generi il linguaggio delle stringhe in cui se non sono presenti a allora sono presenti b.
*** Risposta
((a+c)*(c*)(a+c)*) + ((b+c)*(c*)(b+c)*)

** Data l'espressione regolare E = (a* + bb)* sull'alfabeto {a,b,c}, determinare quale delle seguenti stringhe appartiene al linguaggio generato da E.

- [ ] aaab
- [ ] ab
- [ ] bbab
- [ ] aaa

*** Risposta
Secondo questo alfabeto, per forza devi trovare una serie pari di _b_. Quindi
possiamo scartare tutte le risposte con una _b_ singola, lasciando solo a _aaa_.

- [X] aaab
- [X] ab
- [X] bbab
- [✓] aaa


** Definire un'espressione regolare sull'alfabeto {a,b,c} che generi il linguaggio delle stringhe in cui la prima _a_, se presente è preceduta da un numero dispari di b.
*** Risposta
(b*cb*bb*)*a(b*cb*bb*)*
**** (b*cb*bb*)*
è la parte principale dell'espresionse regolare. questa parte permete un numero arbitrario di ocorrenze di questo patrone:

- b*  :: permete 0 o piu _b_
- c   :: coincide con la letra _c_
- b*  :: permete 0 o piu _b_
- bb* :: permete una _b_ seguita opzionalmente di piu _b_. questo ci conferma che ci sia un nuomer dispari di _b_.

questo insieme ci permete stringhe che contengano la _c_ e un numero dispari di _b_ prima di qualsiasi _a_.
**** a
Simplemente coincide con la _a_.
**** (b*cb*bb*)*
molto simile a la prima parte. permete continuare facendo combinazioni con b e c.
** Data l'espressione regolare E = (bcb+c*)* sull'alfabeto {a,b,c}, determinare quale delle seguenti stringhe appartiene al linguaggio generato da E.

- [ ] cbc
- [ ] bc
- [ ] cbcbc
- [ ] bcbcb

*** Risposta
- [X] cbc
- [X] bc
- [✓] cbcbc
- [X] bcbcb

** Definire un'espressione regolare sull'alfabeto {a,c,s} che generi il linguaggio delle stringhe che iniziano con _as_, finiscono con _sa_  in cui è presente una sola occorrenza della sottostringa _sa_ (alla fine). Ad esempio, le stringhe _asccscsa_, _asa_ , _asssssa_ appartengono al linguaggio, mentre _asas_, _casa_, e _ascsasa_ no.

*** Risposta
as((a+c)*+(s+c)*)sa
** Data l'espressione regolare E = ((0+2)1*0*)* sull'alfabeto {0,1,2}, determinare quale delle seguienti sitring appartiene al linguaggio generato da E.
- [ ] 10
- [ ] 01
- [ ] 120
- [ ] 122
*** Risposta
la risposta è _01_ perche per forza deve iniziare con 0 o 2.
- [X] 10
- [✓] 01
- [X] 120
- [X] 122
* pumping lemma
** Si suponga di voler dimostrare il pumping lemma per il linguaggio regolare L riconosciuto dal seguente DFA con 5 stati
|-----+---+---|
|     | b | c |
|-----+---+---|
|   0 | 0 | 0 |
|  *1 | 2 | 0 |
|   2 | 1 | 3 |
|   3 | 2 | 0 |
| → 4 | 1 | 3 |
|-----+---+---|
Si consideri ora la stringa _w = cbcbb_ ∈ L di lunghezza 5. Per concludere la
dimostrazione vista a lezione viene scelta una partciolrae scomposizione *xyz* di w.
Quale?
- [ ] x = c, y = bcb, z = b
- [ ] x = c, y = b, z = bcb
- [ ] x = c, y = bc, z = bb
- [ ] x = cb, y = c, z = bb

*** Risposta
qua *y* sarebbe la parte che gira tra i diversi stati evitando la linealità del processo del automa.

Quindi con la stringa w l'automa farebe:
4 →(c) 3 →(b) 2 →(c) 3 →(b) 2 →(b) 1

allora la parte 3 →(b) 2 →(c) 3 sarebbe la parte della stringa che gira atraverso
gli stati di maniera no lineare, quindi il nostro y. quindi sarebe
x → c
y → bc
z → bb

- [X] x = c, y = bcb, z = b
- [X] x = c, y = b, z = bcb
- [✓] x = c, y = bc, z = bb
- [X] x = cb, y = c, z = bb

** Si suponga di voler dimostrare il pumping lemma per il linguaggio regolare L riconosciuto dal seguente DFA con 5 stati
|-----+---+---|
|     | 1 | 2 |
|-----+---+---|
|   0 | 0 | 0 |
| * 1 | 0 | 2 |
|   2 | 1 | 2 |
| → 3 | 1 | 2 |
|-----+---+---|
Si consideri ora la stringa _w = 221221_ ∈ L di lunghezza 6. Per concludere la
dimostrazione vista a lezione viene scelta una partciolrae scomposizione *xyz* di w.
Quale?
- [ ] x = 22, y = 1, z = 221
- [ ] x = 2, y = 21, z = 221
- [ ] x = 221, y = 2, z = 21
- [ ] x = 2, y = 2, z = 1221

*** Risposta
#+begin_example
 (2) (2) (1) (2) (2) (1)
3 → 2 → 2 → 1 → 2 → 2 → 1
#+end_example

quindi dal inizio si riconosce che il _2 → 2_ non affetta al percorso.

#+begin_example
 (2)|  (2)  |(1) (2) (2) (1)
3 → | 2 → 2 | → 1 → 2 → 2 → 1
#+end_example

- [X] x = 22, y = 1, z = 221
- [X] x = 2, y = 21, z = 221
- [X] x = 221, y = 2, z = 21
- [✓] x = 2, y = 2, z = 1221

** Si suponga di voler dimostrare il pumping lemma per il linguaggio regolare L riconosciuto dal seguente DFA con 5 stati
|----+---+---+---|
|    | a | b | c |
|----+---+---+---|
|  0 | 0 | 0 | 0 |
| *1 | 0 | 0 | 0 |
|  2 | 3 | 0 | 1 |
|  3 | 0 | 2 | 0 |
| →4 | 3 | 0 | 1 |
|----+---+---+---|

Si consideri ora la stringa _w = ababc_ ∈ L id lunghezza 5. Per concludere la
dimostrazione vista a lezione viene scelta una partciolrae scomposizione *xyz* di w.
Quale?

- [ ] x = a, y = ba, z = bc
- [ ] x = a, y = bab, z = c
- [ ] x = ab, y = a, z = bc
- [ ] x = a, y = b, z = abc

*** Risposta
#+begin_example
 (a) |(b) (a) |(b) (c)
4 → 3| → 2 → 3| → 2
#+end_example

la metta meno utile sarebe con y= ba

- [✓] x = a, y = ba, z = bc
- [X] x = a, y = bab, z = c
- [X] x = ab, y = a, z = bc
- [X] x = a, y = b, z = abc
* Grammatiche
** Data la gramatica G avente simbolo iniziale B
B → D | BaD
D → E | ϵ
E → d
individuare quale tra le seguenti è una stringa generata da G.
- [ ] dda
- [ ] aad
- [ ] add
*** Risposta
B → Bad → BaDaD → DaDaD → ϵaϵad → aad
- [X] dda
- [✓] aad
- [X] add
** Definire una CFG che generi il linguaggio {aᵐ(bc)ⁿ|0 ≤ m ≤ n}
*** Risposta
** Definire una CFG che generi il linguaggio {(ab)ⁱ(ba)ʲ|0 ≤ i ≤ j}
*** Risposta
A → ab | abAB
B → ba
**** test
A → abAB → ababABB → abababBB → abababbaba
** Data la grammatica G avente simbolo iniziale E
B → ϵ
C → c | bC
E → EBC | ϵ

individuare quale tra le seguenti è una stringa generata da G

- [ ] cbc
- [ ] bb
- [ ] bcb

*** Risposta
E → EBC → EBbC → EBbc → Ebc → EBCbc → BCbc → Cbc → cbc

- [✓] cbc
- [X] bb
- [X] bcb

** Data la grammatica G avente simbolo iniziale B
B → BCD| ϵ | c
C → b
D → ϵ | c

individuare quale tra le seguenti è una stringa generata da G

- [ ] ccc
- [ ] bcc
- [ ] cb

*** Risposta
X : B → BCD → cbc
✓ : B → BCD cbϵ → cb

- [X] ccc
- [X] bcc
- [✓] cb

** Definire una CFG che generi il linguaggio {aᵐb^(m+n mod2) aⁿ}
*** Risposta

* Derivazioni
** data la grammatica G. Individuare quale tra le seguenti è una derivazione canonica _destra_ di G.

#+begin_example
A → EcC
C → ϵ | A
D → AbA
E → c
#+end_example
- [ ] D → AbA → EcCbA → ccCbA → ccCbEcC
- [ ] D → AbA → EcCbA → EcAbA → EcEcCbA
- [ ] D → AbA → AbEcC → AbEc → Abcc
- [ ] D → AbA → EcCbA → EcCbEcC → EcCbEcA

*** Risposta
- [X] D → AbA → EcCbA → ccCbA → ccCbEcC
- [X] D → AbA → EcCbA → EcAbA → EcEcCbA
- [✓] D → AbA → AbEcC → AbEc → Abcc
- [X] D → AbA → EcCbA → EcCbEcC → EcCbEcA
** Data la grammatica G, Individuare quale tra le seguenti è una derivazione canonica _sinistra_ di G
#+begin_example
A → cb
B → a | CE
C → cAa
E → adA
#+end_example



- [ ] B → CE → cAaE → ccbaE → ccbaadA
- [ ] B → CE → CadA → cAaadA → cAaadcb
- [ ] B → CE → CadA → Cadcb → cAaadcb
- [ ] B → CE → cAaE → cAaadA → cAaadcb

*** Risposta

- [✓] B → CE → cAaE → ccbaE → ccbaadA
- [X] B → CE → CadA → cAaadA → cAaadcb
- [X] B → CE → CadA → Cadcb → cAaadcb
- [X] B → CE → cAaE → cAaadA → cAaadcb

** Data la grammatica G, Individuare quale tra le seguenti è una derivazione canonica _sinistra_ di G
#+begin_example
A → add | cE
B → b
E → B | AA
#+end_example

- [ ] E → AA → Aadd →cEadd → cBadd
- [ ] E → AA → cEA →cAAA → caddAA
- [ ] E → AA → Aadd →cEadd → cAAadd
- [ ] E → AA → AcE →AcB → Acb

*** Risposta

- [X] E → AA → Aadd →cEadd → cBadd
- [✓] E → AA → cEA →cAAA → caddAA
- [X] E → AA → Aadd →cEadd → cAAadd
- [X] E → AA → AcE →AcB → Acb
** Data la grammatica G, Individuare quale tra le seguenti è una derivazione canonica _sinistra_ di G
A → CB
B → ϵ
C → E | DcC
D → A
E → ϵ

- [ ] A → CB → EB → E → ϵ
- [ ] A → CB → C → E → ϵ
- [ ] A → CB → DcCB → AcCB → CBcCB
- [ ] A → CB → C → DcC → DcDcC

*** Risposta

A → CB → DcCB → AcCB → CBcCB

- [X] A → CB → EB → E → ϵ
- [X] A → CB → C → E → ϵ
- [✓] A → CB → DcCB → AcCB → CBcCB
- [X] A → CB → C → DcC → DcDcC

* automi a pila
** Sia P = ({q},{a,c},{a,c,B,D,E},δ,q,E,{q}) un automa a pila che esegue la mossa
                           (q,a,EBB) ⊢ₚ (q,a,BDaBBB)
Quale delle seguenti relazioni giustifica questa mossa?
*** Risposta
|--------------+---+------------|
| (q,a,BDaBBB) | → | (q,a,EBBB) |
| *TOGLI*        |   | *AGGIUNGI*   |
| (q,BDa)      | ∈ | (q,ϵ,E)     |
|--------------+---+------------|
quindi la risposta giusta sarebbe (q,BDa) ∈ (q,ϵ,E)
** Sia P = ({q},{a,b,c,d},{a,c,d,B,C,D,E},δ,q,C,{q})un automa a pila che esegue la mossa
                            (q,cdc,cEc) ⊢ₚ (q,dc,Ec)
Quale delle seguenti relazioni giustifica questa mossa?

*** Risposta
ora si inverte(non sono sicuro perche)

|-----------+---+-------------|
| (q,dc,Ec) | → | (q,cdc,cEc) |
| togli     |   | aggiungi    |
| (q,ϵ)      |   | (q,c,c)     |
|-----------+---+-------------|

pratticamente non toglie niente e aggiunge una c in ogni parola

Risposta: (q,ϵ) ∈ (q,c,c)

** Sia P = ({q},{a,b,c,d},{a,bc,d,A,C,D},δ,q,C,{q}) un automa a pila che esegue la mossa

                         (q,bcbbb,Cbb)⊢ₚ(q,bcbbb,Cbbb)

Quale delle seguenti relazioni giustifica questa mossa?

- [ ] (q,Cb) ∈ δ(q,ϵ,C)
- [ ] (q,D) ∈ δ(q,ϵ,C)
- [ ] (q,ϵ) ∈ δ(q,b,b)
- [ ] (q,b) ∈ δ(q,ϵ,A)
*** Risposta
(q,Cb) ∈ δ(q,ϵ,C)

che significa
|-----+----------------+-----+-------------------------+-------------------------|
| (q, | Cb)            | (q, | ϵ,                       | C)                      |
|     | Cosa aggiungo? |     | Cosa tolgo del blocco 2 | Cosa tolgo nel 3 blococ |
|-----+----------------+-----+-------------------------+-------------------------|

- [✓] (q,Cb) ∈ δ(q,ϵ,C)
- [X] (q,D) ∈ δ(q,ϵ,C)
- [X] (q,ϵ) ∈ δ(q,b,b)
- [X] (q,b) ∈ δ(q,ϵ,A)
** Sia P = ({q},{a,b},{a,b,B,E},δ,q,B,{q}) un  automa a pila che esegue la mossa
(q,aa,aB) ⊢ₚ (q,a,B)

- [ ] (q,a) ∈ δ(q,ϵ,E)
- [ ] (q,ϵ) ∈ δ(q,b,b)
- [ ] (q,ϵ) ∈ δ(q,a,a)
- [ ] (q,ϵ) ∈ δ(q,ϵ,B)

*** Risposta
Nello stato q, non si mette niente(ϵ) e toglia una _a_ della stringa e una _a_ della pila: (q,ϵ) ∈ δ(q,a,a)

- [X] (q,a) ∈ δ(q,ϵ,E)
- [X] (q,ϵ) ∈ δ(q,b,b)
- [✓] (q,ϵ) ∈ δ(q,a,a)
- [X] (q,ϵ) ∈ δ(q,ϵ,B)
* Grammatiche LL(1)
** Le seguenti produzioni appartengono a una grammatica G avente simbolo iniziale B

                               A → Ecc | caE | cb

Quale tra le seguenti relazioni è _sicuramente_ vera senza conoscere l'intera grammatica
- [ ] FOLLOW(A) ⊂ FOLLOW(E)
- [ ] c ∈ FOLLOW(A)
- [ ] FOLLOW(B) ⊂ FOLLOW(A)
*** Risposta

Argomentando un po ogni possibile risposta:

- FOLLOW(A) ⊆ FOLLOW(E) :: Possiamo confermarlo perche effetivamente il FOLLOW(E) appartiene a FOLLOW(A) perche E viene subito dopo la A nel caso _Ecc_.

- c ∈ FOLLOW(A) :: Non puo essere giusto perche c viene dopo E, che apartiene a FOLLOW(A), quindi c ∈ FOLLOW(E).

- FOLLOW(B) ⊆ FOLLOW(A) :: direttamente B non si trova nella produzione vista.

- [✓] FOLLOW(A) ⊂ FOLLOW(E)
- [X] c ∈ FOLLOW(A)
- [X] FOLLOW(B) ⊂ FOLLOW(A)

** Data la seguente grammatica il cui simbolo iniziale è D. mostrare FIRST e FOLLOW di tutte le variabili e gli insimi guida di tutte le produzioni. La grammatica è LL(1)?
B → c|CBC
C → ϵ|d
D → E
E → Bd
*** Risposta
|---+------+-------+--------|
|   | NULL | FIRST | FOLLOW |
|---+------+-------+--------|
| B |      | {c,d} | {d}    |
| C | ✓    | {d}   | {c,d}  |
| D |      | {c,d} | {$}    |
| E |      | {c,d} | {$}    |
|---+------+-------+--------|

|---------+-------|
| INSIEMI | GUIDA |
|---------+-------|
| B → c   | {c}   |
| B → CBC | {c,d} |
| D → E   | {c,d} |
| E → Bd  | {c,d} |
|---------+-------|
** Le seguenti produzioni appartengono a una grammatica G avente simbolo iniziale D
                               A → ϵ | ac | aB
Quale tra le seguenti relazioni è *sicuramente* vera senza conoscere l'intera grammatica.

- [ ] FOLLOW(A) ⊆ FOLLOW(B)
- [ ] c ∈ FOLLOW(A)
- [ ] a ∈ FOLLOW(A)

*** Risposta

- [X] FOLLOW(A) ⊆ FOLLOW(B)
- [X] c ∈ FOLLOW(A)
- [✓] a ∈ FOLLOW(A)

** Data la seguente grammatica il cui simbolo iniziale è E. mostrare FIRST e FOLLOW di tutte le variabili e gli insimi guida di tutte le produzioni. La grammatica è LL(1)?
                                  A → EB  | bbC
                                  B → ϵ
                                  C → c
                                  E → dAd | ϵ
*** Risposta
iniziando da _E_
**** NULL, FIRST & FOLLOW
FIRST(Xα) = FIRST(X) ∪ FIRST(α), se NULL(X)
          = FIRST(X)           , altrimenti
FOLLOW(A)
1. Se A → α Bβ, allora annotare FIRST(β)⊂FOLLOW(B).
2. Se A → α Bβ, e NULL(β), allora annotare FOLLOW(A) ⊂ FOLLOW(B)
3. se A → α B, allora annotare FOLLOW(A) ⊂ FOLLOW(B)

|------------+------+-------+--------|
| produzione | NULL | FIRST | FOLLOW |
|------------+------+-------+--------|
| A          | ✓    | {b,d} | {d}    |
| B          | ✓    | ø     | {d}    |
| C          |      | {c]   | {d}    |
| E          | ✓    | {d}   | {$,d}  |
|------------+------+-------+--------|

***** A
come tanto E come B sono anulabile,allora anche A è anulabile.

FIRST(A)  = FIRST(E) ∪ FIRST(B) ∪ FIRST(b) = {b,d}
FOLLOW(A) = FIRST(d) = d

***** B
B è NULL perche _B → ø_

FIRST(B)  = ϵ → ø
FOLLOW(B) = FOLLOW(A) = {d}

***** C
C è NULL perche _C → c_

FIRST(C)  = c
FOLLOW(C) = FOLLOW(A) = d

***** E
E è NULL perche _E → ø_

FIRST(E)  = d
FOLLOW(E) = $ ∪ FOLLOW(A) ={$,d}

**** GUIDE

GUIDA(A → α) = FIRST(α) ∪ FIRST(A), se NULL(α)
             = FIRST(α)           , altrimenti

|------------+---------------------------------+-------|
| Produzione | logica                          | guida |
|------------+---------------------------------+-------|
| A → EB     | FIRST(E) ∪ FIRST(B) ∪ FOLLOW(A) | {d}   |
| A → bbC    | FIRST(b)                        | {b}   |
| B → ϵ       | FOLLOW(B)                       | {d}   |
| C → c      | FIRST(c)                        | {c}   |
| E → dAd    | FIRST(d)                        | {d}   |
| E → ϵ       | FOLLOW(E)                       | {$,d} |
|------------+---------------------------------+-------|

** Le seguenti produzioni appartengono a una grammatica G avente simbolo iniziale D
                               A → abd | Cc | Ea
Quale tra le seguenti relazioni è *sicuramente* vera senza conoscere l'intera grammatica?
- [ ] a ∈ FOLLOW(E)
- [ ] FOLLOW(E) ⊆ FOLLOW(A)
- [ ] d ∈ FOLLOW(A)
*** Risposta

_a ∈ FOLLOW(E)_ vuol dire che _a_ viene dopo l'essecuzione di E.

- [✓] a ∈ FOLLOW(E)
- [X] FOLLOW(E) ⊆ FOLLOW(A)
- [X] d ∈ FOLLOW(A)

** Data la seguente grammatica il cui simbolo iniziale è C. mostrare FIRST e FOLLOW di tutte le variabili e gli insimi guida di tutte le produzioni. La grammatica è LL(1)?
A → Ebc | ad
B → ϵ
C → BdE | BAb
E → ϵ
*** Risposta

|---+------+---------+---------|
|   | NULL | FIRST   | FOLLOW  |
|---+------+---------+---------|
| A |      | {a,b}   | b       |
| B | ✓    | ø       | {a,b,d} |
| C |      | {a,b,d} | $       |
| E | ✓    | ø       | {$,b}   |
|---+------+---------+---------|

GUIDA(A → α) = FIRST(α) ∪ FIRST(A), se NULL(α)
             = FIRST(α)           , altrimenti

GUIDA(A → Ebc) = FIRST(E) ∪ FIRST(b) = {b}
GUIDA(A → ad) = FIRST(a) ∪ = {a}
GUIDA(B → ϵ)  = FOLLOW(B) =  {a,b,d}
GUIDA(C → BdE) = FIRST(d) = {d}
GUIDA(C → BAb) = FIRST(B) ∪ FIRST(A) = FIRST(A) = {a,b}
GUIDA(E → ϵ) = FOLLOW(E) = {$,b}

** Le seguenti produzioni appartengono a una grammatica G avente simbolo iniziale E

C → E | DCb
D → E
E → ϵ | aC

individuare quale, tra le seguenti è una stringa generata da G.
- [ ] b
- [ ] aaa
- [ ] aba
*** Risposta
E → aC → aE → aaC → aaE → aaaC → aaaE → aaa

- [X] b
- [✓] aaa
- [X] aba

** Le seguenti produzioni appartengono a una grammatica G avente simbolo iniziale D

                               A → d | ϵ | BCA

Quale tra le seguenti relazioni è _sicuramente_ vera senza conoscere l'intera grammatica
- [ ] d ∈ FOLLOW(C)
- [ ] FOLLOW(B) ⊂ FOLLOW(A)
- [ ] FOLLOW(C) ⊂ FOLLOW(D)

*** Risposta
- _FOLLOW(B) ⊂ FOLLOW(A)_ non puo essere perche _FOLLOW(B) ⊂ FOLLOW(c)_
- _FOLLOW(C) ⊂ FOLLOW(D)_ non puo essere perche non si trova D in questa produzione.
quindi l'unica restante è _d ∈ FOLLOW(C)_ perche FOLLOW(C) = FIRST(A)= FIRST(d) = {d}

- [✓] d ∈ FOLLOW(C)
- [X] FOLLOW(B) ⊂ FOLLOW(A)
- [X] FOLLOW(C) ⊂ FOLLOW(D)

* Attributi
** Le seguente produzione con asscoate _regole semantiche_ in cui gli Sᵢ (se presenti) sonon attributi _sintetizzati_ e gli eᵢ (se presenti) sono attributi _ereditati_, appartiene a una SDD

                   A → BCD {A.s₀=D.s₂, A.s₁=D.s₂, A.s₂=D.s₀}

- [ ] che puo essere L-attribuita ma non S-attribuita
- [ ] che puo essere S-attribuita
- [ ] che non è L-attribuita
*** Risposta
- S-attribuita :: SSD con solo attributi sintetizzati.

- L-attribuita :: SSD dove tutti gli attributi derivano dalla A o dalla sinistra.

- attribuita mista :: SSD con solo attributi sintetizzati(non eredati) che deivano dalla A.

- [X] che puo essere L-attribuita ma non S-attribuita
- [✓] che puo essere S-attribuita.
- [X] che non è L-attribuita

** Le seguente produzione con asscoate _regole semantiche_ in cui gli Sᵢ (se presenti) sonon attributi _sintetizzati_ e gli eᵢ (se presenti) sono attributi _ereditati_, appartiene a una SDD

                   A → BCDE {A.s₀=E.s₁, A.s₂=B.s₀, A.e₂=D.s₂}

- [ ] che puo essere L-attribuita ma non S-attribuita
- [ ] che puo essere S-attribuita
- [ ] che non è L-attribuita
*** Risposta
Non puo essere _S-Atribuitta_ perche ha A.e₂, che sarebbe un'attributo ereditato.
Essendo una produzione non viene limitato a guardare alla sua sinistra, quindi puo
essere un L-attribuita.

- [✓] che puo essere L-attribuita ma non S-attribuita
- [X] che puo essere S-attribuita
- [X] che non è L-attribuita

** Le seguente produzione con asscoate _regole semantiche_ in cui gli Sᵢ (se presenti) sonon attributi _sintetizzati_ e gli eᵢ (se presenti) sono attributi _ereditati_, appartiene a una SDD

                   A → BCD {A.s₀=D.s₂, A.s₁=D.s₀, A.e₀= C.e₂,C.e₂=A.e₂}

- [ ] che puo essere L-attribuita ma non S-attribuita
- [ ] che puo essere S-attribuita
- [ ] che non è L-attribuita
*** Risposta

non puo essere L-attribuita perche sta dichiarando C.e₂=A.e₂, e la  C va dopo che la A nel SDD

- [X] che puo essere L-attribuita ma non S-attribuita
- [X] che puo essere S-attribuita
- [✓] che non è L-attribuita

** Le seguente produzione con asscoate _regole semantiche_ in cui gli Sᵢ (se presenti) sonon attributi _sintetizzati_ e gli eᵢ (se presenti) sono attributi _ereditati_, appartiene a una SDD

                   A → BCD {A.s₁=B.s₀, A.s₂=D.s₁, D.e₁ = B.s₁}

- [ ] che puo essere L-attribuita ma non S-attribuita
- [ ] che puo essere S-attribuita
- [ ] che non è L-attribuita

*** Risposta
puo essere L-attribuita perche l'unico atributo che non deriva della A, è
la  _D.e1 = B.s1_ ma non è un problema perche la B è a sinistra della D.

E non puo essere un S-attribuito perche c'è _D.e₁_ che sarebbe eredità.

- [✓] che puo essere L-attribuita ma non S-attribuita
- [X] che puo essere S-attribuita
- [X] che non è L-attribuita

* analisi statica
** Determinare il massimo di operandi contemporaneamente presenti sulla piladurante la valutazione della seguente espressione
(z / 8 + 8) * x
*** Risposta
**** Z / 8: 2
|   |
|---|
| 8 |
|---|
| z |
|---|

|     |
|-----|
|     |
|-----|
| z/8 |
|-----|

**** z/8 + 8: 2
|     |
|-----|
|  8  |
|-----|
| z/8 |
|-----|

**** (z/8 + 8) * x: 2
|       |
|-------|
| x     |
|-------|
| z/8+8 |
|-------|

|           |
|-----------|
|           |
|-----------|
| (z/8+8)*x |
|-----------|

**** conclusione
nessun punto dell'espressione opera con piu di *2* operandi.

** Determinare il massimo di operandi contemporaneamente presenti sulla piladurante la valutazione della seguente espressione
5 - z + (z + x) + 7
*** Risposta
lo stack secondo le struzioni viene:
#+begin_src C
ldc 5;
iload z;
isub;
#+end_src
|---+-------|
| Nᵒ | stack |
|---+-------|
| 2 | z     |
| 1 | 5     |
|---+-------|

#+begin_src C
iload(z);
iload(x);
iadd;
iadd;
#+end_src
|---+-------|
| Nᵒ | stack |
|---+-------|
| 3 | x     |
| 2 | z     |
| 1 | 5 - z |
|---+-------|

#+begin_src C
ldc 7;
iadd;
#+end_src
|---+---------------|
| Nᵒ | stack         |
|---+---------------|
| 2 | 7             |
| 1 | 5 - z + (z+x) |
|---+---------------|

ci sono massimo 3 operandi
** Determinare il massimo di operandi contemporaneamente presenti sulla piladurante la valutazione della seguente espressione
y * y / 5 + 2
*** Risposta
il codice deve iniziare insirendo le prime numeri di moltiplicazione e divisone con
#+begin_src C
iload y;
iload y;
ldc 5;
#+end_src

| 5 |
| y |
| y |
|---|
count=3
per dopo fare l'operazioni di divisione e moltiplicazione
#+begin_src C
idiv
imul
#+end_src
che va da
| 5        |            |
| y        | /          |
| y        | *          |
|----------+------------|
| operandi | operazioni |
a
| y*y/5 |
|-------|
count=1
ora si mete il +2
#+begin_src c
ldc 2
iadd
#+end_src
| 2        |            |
| y*y/5    | +          |
|----------+------------|
| operandi | operazioni |
count=2

_il numero massimo di operandi sarebbe 3_
** Determinare il massimo di operandi contemporaneamente presenti sulla piladurante la valutazione della seguente espressione
#+begin_src java
while(z <= 2) z = 2 + x;
#+end_src
*** Risposta
#+begin_src c
L0:
iload z;
ldc 2;
if_cmple L1;
goto STOP;
L1:
ldc 2;
iload x;
iadd;
istore z;
goto L0;
#+end_src

** Ricordando le SDD viste a lezione per il calcolo dell'attributo _stack_, determinare il numero massimo di operandi contemporaneamente presenti sulla pila durante la valutazione della seguente espressione .
z + 10 / 7 + 6
*** Risposta
#+begin_src c
iload z
ldc 10
ldc 7
#+end_src
|  7 |
| 10 |
|  z |
|----|

_count=3_ questa è la quantita massima di operandi che ci sono nello stack.
Dopo solo continua come
#+begin_src c
idev
isum
ldc 6
isum
#+end_src

| z + 10/7 +6 |
|-------------|

* traduzione inversa
** Qual è il comando che viene tradotto nel codice seguente
#+begin_src c
L0:
iload x;
iload z;
if icomplt L1
goto STOP;
L1:
ldc 5;
iload z;
iadd;
ldc 10;
imul;
istore x;
goto L0;
#+end_src
*** Risposta
analizzando i pezzi del codice abbiamo:

#+begin_src C
L0:
....
goto L0
#+end_src
questa chiamata della fine che ci riporta all'inizio è un _while_
#+begin_src java
while(){
}
#+end_src



#+begin_src c
iload x;
iload z;
if icomplt L1;
goto STOP;
#+end_src
questo pezzo ci fa  _x<z_ o salta a _STOP_
#+begin_src java
while(x<z){
}
#+end_src


finalmente ci mettiamo all'esecuzione del codice L1
#+begin_src c
L1:
ldc 5;
iload z;
iadd;
ldc 10;
imul;
istore x;
#+end_src
che a poche parole sarebbe la linea di esecuzione
#+begin_src java
while(x<z){
    x=(5+z)*10;
}
#+end_src

** Qual è il comando che viene tradotto nel codice seguente
#+begin_src c
iload x;
iload z;
if icomplt L0
goto L1;
L0:
ldc 9;
istore y;
goto STOP;
L1:
iload x;
istore y;
goto STOP;
#+end_src
*** Risposta
#+begin_src java
if(x<y){
    y=9;
}else{
   y=x;
}
#+end_src

* Schemi di traduzione
** Definire uno schema di traduzione _(SDT)_ e il codice¹ Java del parser ricorsivo dicsendente che riconosce il linguaggio delle stringue della forma _aᵏbc²ᵏ_ e che calcola il numero totale di simboli presenti

*** SDD
S → A
A → aAcc | b
*** SDT
S → A {System.out.println(1 + A.val*3)}
A → aAcc{A.val = A.i + 1} | b
*** Parser
#+begin_src java
private void S(){
    switch(look.token){
        case 'a':
        case 'b':
            int val = A(0);
            match(Tag.EOF);
            System.out.println(1 + val*3);
            break;
        default:
            error("not valid token");
    }
}

private int A(int i){
    int val = i;
    switch(look.token){
        case 'a':
            match('a');
            val = A(val+1);
            match('c');
            match('c');
            break;
        case 'b':
            match('b');
        default:
            error("not valid token");
    }
    return val;
}
#+end_src
