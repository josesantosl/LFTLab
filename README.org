#+title: Riasunto del progetto
#+author: José Adrian Santos Lertora (pepito)

Faccio questo riassunto come aiuto per fare spiegare meglio questo codice e anche
per confermare che ho spiegato ogni punto 5 del progetto.

* Token, words & numToken
un Token è l'oggetto piu piccolo di questo progetto. solo contiene una variabile int
chiamata _tag_ per riconoscere quale token è ognuno. La clase [[file:Esercizio5/Token.java][Token]] ha un'insieme di
Token gia definiti, quelli che solo sono un simbolo, in questo caso il suo tag è lo
stesso simbolo in ASCII.

#+BEGIN_SRC java
not = new Token('!'),
lpt = new Token('('),
rpt = new Token(')'),
lpq = new Token('['),
rpq = new Token(']'),
lpg = new Token('{'),
rpg = new Token('}'),
plus = new Token('+'),
minus = new Token('-'),
underscore = new Token('_'),
mult = new Token('*'),
div = new Token('/'),
semicolon = new Token(';'),
comma = new Token(',');
#+END_SRC
|---------------------------+---------+------|
| Token                     | Pattern | Nome |
|---------------------------+---------+------|
| Negazione                 | !       |   33 |
| Parentesi tonda sinistra  | (       |   40 |
| Parentesi tonda destra    | )       |   41 |
| Parentesi quadra sinistra | [       |   91 |
| Parentesi quadra destra   | ]       |   93 |
| Parentesi graffa sinistra | {       |  123 |
| Parentesi graffa destra   | }       |  125 |
| Somma                     | +       |   43 |
| sottrazione               | -       |   45 |
| Moltiplicazione           | *       |   42 |
| Divisione                 | /       |   47 |
| Punto e virgola           | ;       |   59 |
| Virgola                   | ,       |   44 |
|---------------------------+---------+------|

** Word
#+BEGIN_SRC java
public class Word extends Token
#+END_SRC

La classe [[file:Esercizio5/Word.java][Word.java]] viene come estensione di Token. Se per Token solo usavamo un unico
simbolo, ora in Word noi usiamo un insieme di simboli, o anche parole come si intende
con il nome. mantiene il _tag_ di Token ma anche aggiunge la stringa _lexeme_, che serve
per salvare il testo della stessa parola, perche puo succedere che sono lo stesso
tipo di token ma con testi diversi(come ID o RELOP)
*** Tag
Word non usa più il codice ASCII dei simboli, perche usa piu di un simbolo allo stesso
tempo. Per queste parole dovremo chiedere alla classe Tag.java contiene tutti i
codici che ci servono per le parole

|----------------+---------------------------------------+------|
| Token          | Pattern                               | Nome |
|----------------+---------------------------------------+------|
| Numeri         | Costante numerica                     |  256 |
| Identificatore | Lettera seguita da lettere e cifre    |  257 |
| Relop          | Operatore relazionale(<,>,<=,>=,==,<> |  258 |
| Assegnamento   | Assign                                |  259 |
| To             | to                                    |  260 |
| Conditional    | conditional                           |  261 |
| Option         | option                                |  262 |
| Do             | do                                    |  263 |
| Else           | else                                  |  264 |
| While          | while                                 |  265 |
| Begin          | begin                                 |  266 |
| End            | end                                   |  267 |
| Print          | print                                 |  268 |
| Read           | read                                  |  269 |
| Disgiunzione   | doppia barra verticale(OR)            |  270 |
| Congiunzione   | &&                                    |  271 |
| EOF            | Fine dell'input                       |   -1 |
|----------------+---------------------------------------+------|

*** Costruttore
Il suo costruttore è
#+BEGIN_SRC java
    public Word(int tag, String s) { super(tag); lexeme=s; }
#+END_SRC

|-----------+----------|
| argomento | variable |
|-----------+----------|
| tag       | tag      |
| s         | lexeme   |
|-----------+----------|

guarda che per il tag usa la funzione _super()_, questo serve per assegnare le
variabili che sono gia nel costruttore del padre, in questo caso sarebbe al
costruttore di Token che è

#+BEGIN_SRC java
public Token(int t) { tag=t; }
#+END_SRC

questo sarebbe come fare (penso che se lo fai non ti compila)

#+BEGIN_SRC java
public Word(int tag, String s) { new Token(tag); lexeme=s; }
#+END_SRC

** NumberTok
#+BEGIN_SRC java
public class NumberTok extends Token
#+END_SRC

Anche NumberTok è una estensione di Token. la principale funzione del NumberTok è
di poter salvare il numero come un valore intero e no una parola.

* Lexer
* SymbolTable
* CodeGenerator & Instruction
Il code generator contiene una lista di istruzioni e un contatore.
#+begin_src java
LinkedList <Instruction> instructions = new LinkedList <Instruction>();
int label=0;
#+end_src
** Istruzione
La principale funzione del [[file:Esercizio5/CodeGenerator.java][CodeGenerator]] è quello di emitere le istruzioni che
controlla _Jasmin_ (Java Bytecode Instructions). Per fare questo si usa la funzione
emit e la classe Instruction.
#+begin_src java
public void emit(OpCode opCode) {
    instructions.add(new Instruction(opCode));
}

public void emit(OpCode opCode , int operand) {
    instructions.add(new Instruction(opCode, operand));
}
#+end_src

Queste istruzione vengono create secondo la tabella
|--------------+-----------------------------------------------------------|
| Istruzione   | Descrizione                                               |
|--------------+-----------------------------------------------------------|
| ldc          | Scrive una costante in cima allo stack.                   |
| imul         | Moltiplicare due numeri interi                            |
| ineg         | Negare int                                                |
| idiv         | Dividere due numeri interi                                |
| iadd         | Somma due numeri                                          |
| isub         | Int sottrarre                                             |
| istore id    | Memorizza il valore int nella variabile id                |
| ior          | Operazione OR bit a bit tra due numeri                    |
| iand         | Operazione AND bit a bit tra due numeri                   |
| iload        | Carica un int da una variabile                            |
| GOto L       | Salta al label L                                          |
| if_icmpeq L  | Se i due valori sono uguali salta al label L.             |
| if_icmple L  | Se value1 è minore o uguale a value2, salta al label L.   |
| if_icmplt L  | Se value1 è minore a value2, salta al L.                  |
| if_icmpne L  | Se i due valori sono diversi salta al label L.            |
| if_icmpge L  | Se value1 è maggiore o uguale a value2, salta al label L. |
| if_icmpgt L  | Se value1 è maggiore a value2, salta al label L.          |
| ifne L       | Se il valore è diverso da 0, salta al label L.            |
| invokestatic | Chiama a un'altro metodo.                                 |
| dup          | Duplica il valore in cima allo stack.                     |
| pop          | Scartare il valore in cima allo stack.                    |
|--------------+-----------------------------------------------------------|
** Labels
un'altra funzione importante del CodeGenerator è di emitere i label del codice.
I label sono delle etichette per difereneziare le diverse sezioni dell codice, e
sopratutto ci servirà per inidicare con Goto e le condizionali verso a  dove saltare.

per queste cose abbremo le funzione:
- newLabel :: che ci ritorna il nuovo label disponibile e dopo incrementa il contatore 'label'
#+begin_src java
public int newLabel() {
    return label++;
}
#+end_src

- emitLabel :: ci scrive il label specificato come operand in nella lista
  d'istruzioni.
#+begin_src java
public void emitLabel(int operand) {
    emit(OpCode.label, operand);
}
#+end_src

* Translator
** grammatica
[[file:Esercizio5/Translator.java][Translator]] è una espansione del [[file:Esercizio3/Parser32.java][Parser]] dell'esercizio 3, usando la stessa gramatica:

-      <[[prog]]> → <statlist> EOF
-  <[[statlist]]> → <stat> <statlistp>
- <[[statlistp]]> → ; <stat> <statlistp> |ϵ
-      <[[stat]]> → [[assign]] <expr> to <idlist>
              \\| [[print]] [ <exprlist> ]
              \\| [[read]] [idlist]
              \\| [[while]] ( <bexpr> ) <stat>
              \\| [[conditional]] [ <optilist> ] end
              \\| [[conditional]] [ <optilist> ] else <stat> end
              \\| {<statlist>} |
-    <[[idlist]]> → ID <idlistp>
-   <[[idlistp]]> → , ID <idlistp> |ϵ
-  <[[optilist]]> → <optitem> <optilistp>
- <[[optilistp]]> → <optitem> <optilistp> |ϵ
-   <[[optitem]]> → option ( <bexpr> ) do <stat>
-     <[[bexpr]]> → RELOP <expr> <expr>
-             → && <bexpr> <bexpr>
-             → || <bexpr> <bexpr>
-             → ! <bexpr>
-      <[[expr]]> → +(<exprlist>)
-             → *(<exprlist>)
-             → - <expr> <expr>
-             → / <expr> <expr>
-  <[[exprlist]]> → <expr> <exprlistp>
- <[[exprlistp]]> → , <expr> <exprlistp> | ϵ
** prog
#+begin_src java
    private void prog(){//prog() -> statlist(lnext) EOF
		if (look.tag == Tag.EOF) {
			error("file vuoto");
		}

		int proglabel = code.newLabel();
		statlist(proglabel);
		match(Tag.EOF);

		code.emit(OpCode.GOto,proglabel);
		code.emitLabel(proglabel);

        try {
			code.toJasmin();
        }catch(java.io.IOException e) {
			System.err.println("Error writting the Output.j");
		}
    }
#+end_src
* TODO list for this weekend to complete this project
