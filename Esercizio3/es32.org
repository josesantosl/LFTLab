#+title: ESERCIZIO 3.2

si deve scrivere un analizzatore sintatico a discesa ricosiva per la grammatica:
leggendo diverse istruzioni o statiments
* Insieme di produzzione
  <prog>      ::= <statlist> *EOF*
  <statlist>  ::= <stat><statlistp>
  <statlistp> ::= ; <stat><statlistp> | \epsilon
  <stat>      ::= assign <expr> to <idlist>
              ::= print[ <exprlist> ] 
	      ::= read[ <exprlist>]
	      ::= while(<bexpr>) <stat>
	      ::= conditional[<optlist>] end
	      ::= conditional[<optlist>] else <stat> end
	      ::= { <statlist> }
  <idlist>    ::= ID <idlistp>
  <idlistp>   ::= , ID <idlistp> | \epsilon
  <optlist>   ::= <opttem><optlistp>
  <optlistp>  ::= <optitem><optlistp> | \epsilon
  <optitem>   ::= option (<bexpr>) do <stat>
  <bexpr>     ::= RELOP <expr> <expr>
  <expr>      ::= +(<exprlist>)|-<expr><expr>|*(<exprlist>)|/<expr><expr>| *NUM* | *ID*
  exprlist    ::= <expr><exprlistp>
  exprlistp   ::= , <expr> <exprlistp> | \epsilon
  
  
* Espresioni booleane
  si noti che _RELOP_ corrisponde a un elelmento dell'insieme:
      ==
      <>
      >=
      <=
      <
      >

* Scheme-like
espressioni aritmetiche assegnamento e operatori relazioli in _notazione preifssa_ 
(polaca?)

** Espressioni aritmetiche
*** notazione prefissa
*** possono anche comprender ID
*** operatori
**** *+
     variati n-arie n>=1
**** -/
     binarie

 
* Da fare
  a questo parser ancora li manca aggiugngere i patern 
     *Disgiunzione:* || 
     *coniunzione:*  &&
     *negzione:*     !
     
  Questo si risolve spandendo il <bexpr> nell'insieme di produzzione

  <bexpr>     ::= RELOP <expr> <expr>
	      ::= || (<exprlist>)
	      ::= && (<exprlist>)
              ::=  ! <expr>
