#+title: Parser

Il parser contiene:
**** lexer
**** buferReader
**** una funzione Move
* Stringe annullabili
  una stringa è annullabili quando le sue trasformazioni diventano \epsilon.
  nel caso:
  
  A \to a|Bc
  B \to \epsilon|bB
  C \to d|Cc|BB

  facciamo l'esercizio 
  NULL(A)? _NO_
    NULL(a)?  _NO_
    NULL(Bc)? _NO_

  NULL(B)? _SI_
    NULL(\epsilon)?  _SI_
    NULL(bB)? _NO_

  NULL(C)? _SI_
    NULL(d)?  _NO_
    NULL(Cc)? _NO_
    NULL(BB)? _SI_

* FIRST(\alpha)
  FIRST(\alpha) indica gli _inizi_ di \alpha ovvero l'insieme dei simboli 
  terminali che possono trovarsi all'_inizio_ delle stringhe dirvate da \alpha.
** Come calcolare FIRST
   È possibile calcolare _FIRST(\alpha)_ per induzie su \alpha:

      FIRST(\epsilon) = \empty
      FIRST(a) = {a}
      FIRST(A) = \cup_{A \to \alpha} FIRST(\alpha)

      FIRST(X\alpha)= FIRST(X) \cup FIRST(\alpha), se NULL(X)
               = FIRST(X)           , altrimenti
	       
*** Esempio del calcolo di FIRST
    S \to Ac|Ba
    A \to \epsilon|a
    B \to b
    C \to a|Cb
    D \to \epsilon|d|Db
    
    sapendo che FIRST(S) = FIRST(Ac)\cup FIRST(Ba) = FIRST(A) \cup FIRST(c) \cup FIRST(B)
    
    FIRST(A)= FIRST(\epsilon) \cup FIRST(a) = \empty \cup {a}
    FIRST(B)= FIRST(b) = {b}
    FIRST(C)= FIRST(a) \cup FIRST(Cb) = {a} \cup FIRST(C) = {a}
    FIRST(D)= FIRST(\epsilon) \cup FIRST(d) \cup FIRST(Db) = {d} \cup FIRST(D) \cup FIRST(b) = {b,d}
    
    Quindi possiamo chiuedere riprendendo FIRST(S) come {a} \cup {b} \cup {c} = {a,b,c}

* FOLLOW: Seguiti di una variabile
  _FOLLOW(A)_ è l'insieme dei simboli terminali che possono seguire A in 
  una forma sentenziale.
  
  Per convenzione aggiungeremo una sentinella _$_ ai seguiti del simbolo iniziale _S_.
  In questo modo il parser può capire quando è arrivato alla fine della stringa da 
  riconoscere.

** Come calcolare FOLLOW
   si calcola in due fasi.
*** Fase 1
    In questa fase si annotano realiazioni di appartenenza ed inclusione insiemistica 
    secondo il seguente algoritmo
       1. Se A \to \alpha B\beta, allora annotare FIRST(\beta)\sub FOLLOW(B).
       2. Se A \to \alpha B\beta e NULL(\beta), allora annotare FOLLOW(A) \sub FOLLOW(B)

    _Caso particolare_: se A \to \alpha B, allora annotare FOLLOW(A)\sub FOLLOW(B)
*** Fase 2
    Si determinanno i seguiti propagando i simboli terminali(e $) rispettando l'ordine
    delle inclusioni insiemistiche \sub che sono state annotate

    per grammatiche complesse può essere utile fare una tabella con due colonne, l'elenco
    di tutte le variabili ed i seguiti corrispondenti alle avariabili nella seconda.

** Esempio di calcolo di FOLLOW
   usando l'esempio vecchio 

   S \to Ac|Ba
   A \to \epsilon | a
   B \to b
   C \to a |Cb
   D \to \epsilon |d|Db
   
   e ricordando i suoi FIRST

|---+------+-------|
|   | NULL | FIRST |
|---+------+-------|
| S |      | a,b,c |
| A | \check    | a     |
| B |      | b     |
| C |      | a     |
| D | \check    | b,d   |
|---+------+-------|

   $ \in FOLLOW(S)
   FIRST(c) \sub FOLLOW(A)
   FIRST(a) \sub FOLLOW(B)
   FIRST(b) \sub FOLLOW(C)
   FIRST(b) \sub FOLLOW(D)
   \nbsp 
   
   
   quindi

|---+------+-------+--------|
| X | NULL | FIRST | FOLLOW |
|---+------+-------+--------|
| S |      | a,b,c | $      |
| A | \check    | a     | c      |
| B |      | b     | a      |
| C |      | a     | b      |
| D | \check    | b,d   | b      |
|---+------+-------+--------|

* Insieme GUIDA(A\to\alpha)
  è un insieme di simboli terminali che posso aspettare di vedere in stringhe che 
  derivano di A.
  GUIDA(A\to\alpha) = FIRST(\alpha) \cup FIRST(A), se NULL(\alpha)
             = FIRST(\alpha)           , altrimenti
	 
* Grammatiche LL(1)
  diciamo che una grammatcia G=(VTPS) è LL(1) se per ogni coppia di produzioni 
  distente A\to\alpha e A\to\beta in P, abbiamo che 
              GUIDA(A\to\alpha) \cap GUIDA(A\to\beta) = \empty

  - L \to La stringa in input viene analizzata _da sinistra(LEFT) a destra_
  - L \to Il parser cerca di costruire una _direvazione canonica sinistra_ (leftmost)
  - 1 \to Il parser usa _un solo simbolo terminale_ della stringa per scegliere la produzione.

* espresioni aritmetiche 
  E \to TE'
  E'\to +TE' | \epsilon NULL(E')
  T \to FT'
  T'\to *FT'| \epsilon NULL(T')
  F \to (E) | id

** stringe annullabili

|----+---------|
| x  | NULL(X) |
|----+---------|
| E  |         |
| E' | \check       |
| T  |         |
| T' | \check       |
| F  |         |
|----+---------|


** FIRST
  FIRST(E) = FIRST(T) = {(,id}
  FIRST(E')= {+}
  FIRST(T) = FIRST(F) = {(,id}
  FIRST(T')= {*}
  FIRST(F) = {(,id}

** FOLLOW
 - $ \in FOLLOW(E)
 - {+} = FIRST(E') \sub FOLLOW(T)
 - FOLLOW(E) \sub FOLLOW(T)
 - FOLLOW(E) \sub FOLLOW(E')
 - FOLLOW(E') \sub FOLLOW(T)
 - {*} = FIRST(T') \sub FOLLOW(F)
 - FOLLOW(T) \sub FOLLOW(F)
 - FOLLOW(T) \sub FOLLOW(T')
 - FOLLOW(T') \sub FOLLOW(F)
 - {(} = FIRST()) \sub FOLLOW(E)
 
|----+-----------|
| X  | FOLLOW(X) |
|----+-----------|
| E  | $,)       |
| E' | $,)       |
| T  | $,),+     |
| T' | $,),+     |
| F  | $,),+,*   |
|----+-----------|

** GUIDA(A \to \alpha)
   GUIDA(E \to TE')  = FIRST(TE') = FIRST(T) = {(,id}
   GUIDA(E'\to+TE')  = FIRST(+TE')           = {+_}
   GUIDA(E'\to \epsilon)    = FIRST(\epsilon) \cup FOLLOW(E') = FOLLOW(E') = {$,)}
   GUIDA(T \to FT')  = FIRST(FT') = FIRST(F) = {$,),+,*}
   GUIDA(T'\to*FT)   = FIRST(**FT) = FIRST(**)  = {**}
   GUIDA(T'\to \epsilon)    = FIRST(\epsilon) \cup FOLLOW(T') = {$,),+}
   GUIDA(F \to(E))   = FIRST((E)) = FIRST(() = {(}
   GUIDA(F \to id)   = FIRST(id)             = {id}

|---------+--------------|
| A \to \alpha   | GUIDA(A \to \alpha) |
|---------+--------------|
| E \to TE' | {(,id}       |
| E'\to+TE' | {+}          |
| E'\to \epsilon   | {$,)}        |
| T \to FT' | {(,id}       |
| T'\to*FT' | {*}          |
| T'\to \epsilon   | {$,),+}      |
| F \to(E)  | {(}          |
| F \to id  | {id}         |
|---------+--------------|

* Algoritmo di parsing ricorsivo
** java
   In questo caso è una classe abstract perche si riscrive la 
   funzione S() per 
#+BEGIN_SRC java
public abstract Parser() {
    private String w;             //w è la stringa da riconoscere con $ in fondo
    private int    i;             //i è l'indice del seguente simbolo di w da leggere

    protected char peek(){
	return  w.charAt(i);
    }

    protected void match(char a){ //conferma che il seguente simbolo di W è a
	if(peek == a){
	    i++;
	}else{
	    throw error();
	}
    }

    public void parse(String v){  //Start
	w = v + "$";
	i = 0;
	S();                      //S è il simbolo iniziale della grammatica.
	match("$");               //Controlla di aver letto tutta la stringa.
    }
    protected abstract void S();
    protected SyntaxError error(){
	return new SyntaxError();
    }
}
#+END_SRC 
** python3
#+BEGIN_SRC python
w = ""        #w è la stringa da riconoscere con $ in fondo
i = 0         #i è l'indice del seguente simbolo di w da leggere

def match(a): # conferma che il seguente simbolo di W è a
   if w[i] == a:
      i+=1
    else:
      raise Excpetion("unexpected value")

def parse(v):#start
   w = v$
   i = 0
   S()        #S è il simbolo iniziale della grammatica.
   match('$') #Controlla di aver letto tutta la stringa.

def A():      #A \to \alpha_1|...|\alpha_n sono le produzioni per A.
   if w[i] in Guida(A \to \alpha_1):
      pass
   elif w[i] in GUIDA(A \to \alpha_k):
      for x in \alpha_k:
         if terminale(x):
	     match(x)
	 else:
	     x()
   else:
      raise Exception("unexpected value")
#+END_SRC 
* insieme di produzioni
<start> ::= <expr>EOF
<expr>  ::= <term><exprp>
<exprp> ::= +<term><exprp>
        ::= -<term><exprp>
	::= \epsilon
<term>  ::= <fact><termp>
<termp> ::= * <fact> <termp>
        ::= / <fact> <termp>
	::= \epsilon
<fact>  ::= (<expr>) | NUM
