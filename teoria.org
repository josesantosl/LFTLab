#+author: José Santos L.
* Stringe annullabili
  una stringa è annullabili quando le sue trasformazioni diventano \epsilon.
  nel caso:
   
  A → a|Bc
  B → ϵ|bB
  C → d|Cc|BB

  facciamo l'esercizio 
  NULL(A)? _NO_
  NULL(a)?  _NO_
  NULL(Bc)? _NO_
  
   NULL(B)? _SI_
   NULL(ϵ)?  _SI_
   NULL(bB)? _NO_

   NULL(C)? _SI_
   NULL(d)?  _NO_
   NULL(Cc)? _NO_
   NULL(BB)? _SI_

* FIRST(α)
  FIRST(ϵ) indica gli _inizi_ di α ovvero l'insieme dei simboli
  terminali che possono trovarsi all'_inizio_ delle stringhe dirvate da α.
** Come calcolare FIRST
   È possibile calcolare _FIRST(α)_ per induzie su \alpha:

   FIRST(ϵ) = ø
   FIRST(a) = {a}
   FIRST(A) = ∪_{A → α} FIRST(α)

   FIRST(Xα)= FIRST(X) ∪ FIRST(α), se NULL(X)
            = FIRST(X)           , altrimenti
	       
** Esempio del calcolo di FIRST
   S → Ac|Ba
   A → ϵ|a
   B →b
   C →a|Cb
   D →ϵ|d|Db
    
   sapendo che FIRST(S) = FIRST(Ac)∪ FIRST(Ba) = FIRST(A) ∪ FIRST(c) ∪ FIRST(B)
    
   FIRST(A)= FIRST(ϵ) ∪ FIRST(a) = \empty ∪ {a}
   FIRST(B)= FIRST(b) = {b}
   FIRST(C)= FIRST(a) \cup FIRST(Cb) = {a} \cup FIRST(C) = {a}
   FIRST(D)= FIRST(\epsilon) \cup FIRST(d) \cup FIRST(Db) = {d} \cup FIRST(D) \cup FIRST(b) = {b,d}
    
   Quindi possiamo chiuedere riprendendo FIRST(S) come {a} \cup {b} \cup {c} = {a,b,c}

* FOLLOW: Seguiti di una variabile
  _FOLLOW(A)_ è l'insieme dei simboli terminali che possono seguire A in 
  una forma sentenziale.
  
  Per convenzione aggiungeremo una sentinella _$_ ai seguiti del simbolo iniziale _S_.
  In questo modo il parser può capire quando è arrivato alla fine della stringa da 
  riconoscere.

** Come calcolare FOLLOW
   si calcola in due fasi.
**** Fase 1
     In questa fase si annotano realiazioni di appartenenza ed inclusione insiemistica 
     secondo il seguente algoritmo
       1. Se A → α Bβ, allora annotare FIRST(β)⊂FOLLOW(B).
       2. Se A → α Bβ, e NULL(β), allora annotare FOLLOW(A) ⊂ FOLLOW(B)

     _Caso particolare_: se A → α B, allora annotare FOLLOW(A) ⊂ FOLLOW(B)
**** Fase 2
     Si determinanno i seguiti propagando i simboli terminali(e $) rispettando l'ordine
     delle inclusioni insiemistiche \sub che sono state annotate.

     Per grammatiche complesse può essere utile fare una tabella con due colonne, l'elenco
     di tutte le variabili ed i seguiti corrispondenti alle avariabili nella seconda.

** Esempio di calcolo di FOLLOW
   usando l'esempio vecchio 

   S →  Ac|Ba
   A →  ϵ | a
   B →  b
   C →  a | Cb
   D →  ϵ|d|Db
   
   e ricordando i suoi FIRST

|---+------+-------|
|   | NULL | FIRST |
|---+------+-------|
| S |      | a,b,c |
| A | ✓    | a     |
| B |      | b     |
| C |      | a     |
| D | ✓    | b,d   |
|---+------+-------|

   $ ∈ FOLLOW(S)
   FIRST(c) ⊂ FOLLOW(A)
   FIRST(a) ⊂ FOLLOW(B)
   FIRST(b) ⊂ FOLLOW(C)
   FIRST(b) ⊂ FOLLOW(D)

   quindi

|---+------+-------+--------|
| X | NULL | FIRST | FOLLOW |
|---+------+-------+--------|
| S |      | a,b,c | $      |
| A | ✓    | a     | c      |
| B |      | b     | a      |
| C |      | a     | b      |
| D | ✓    | b,d   | b      |
|---+------+-------+--------|

* Insieme GUIDA(A→α)
  è un insieme di simboli terminali che posso aspettare di vedere in stringhe che 
  derivano di A.
  GUIDA(A → α) = FIRST(α) ∪ FIRST(A), se NULL(α)
               = FIRST(α)           , altrimenti

quindi  usando le tabelle di prima

|---+------+-------+--------+-------|
| X | NULL | FIRST | FOLLOW | GUIDA |
|---+------+-------+--------+-------|
| S |      | a,b,c | $      |       |
| A | ✓    | a     | c      |       |
| B |      | b     | a      |       |
| C |      | a     | b      |       |
| D | ✓    | b,d   | b      |       |
|---+------+-------+--------+-------|
* Grammatiche LL(1)
  diciamo che una grammatcia G=(VTPS) è LL(1) se per ogni coppia di produzioni 
  distente A\to\alpha e A→α in P, abbiamo che
           GUIDA(A→α) ∩ GUIDA(A→β) = ø

  - L → La stringa in input viene analizzata _da sinistra(LEFT) a destra_
  - L → Il parser cerca di costruire una _direvazione canonica sinistra_ (leftmost)
  - 1 → Il parser usa _un solo simbolo terminale_ della stringa per scegliere la produzione.

* 5.1 Definizioni dirette dalla sintassi (SDD)
  
  Una Definizioni dirette dalla sintassi è una grammatica le cui produziono 
  sono associate a zero o più _regole semantiche_ che specificano come calcolare
  il valore degli attributi associati ai nodi degli alberi. sintattici della
  grammatica.

  consistono in:

  - Una grammatica libera che specifica la *sintassi* dei prgoramm ida tradurre.
  - Un insieme di *attributi* associati alle variabili della grammatica e che contengono 
    il _risultato della traduzzione_ (o comunque informazioni accessorie alla traduzione)
  - Un insieme di *regole semantiche* che specifiano come calcolare il vaolore degli attributi 
    e quindi come tradurre il programma.
 
|------------+-------------------+----|
| produzioni | Regole semantiche | n° |
|------------+-------------------+----|
| E → E₁ + T  | E.v = E₁ .v + T.v  |  1 |
| E → T      | E.v = T.v         |  2 |
| T → T₁ * F  | T.v = T₁ .v X F.v  |  3 |
| T → F      | T.v = F.v         |  4 |
| F → (E)    | F.v = E.v         |  5 |
| F → n      | F.v = n.v         |  6 |
|------------+-------------------+----|

** Albero sintattico annotato
   Un albero sintattico annotato è un albero sintattico in cui ogni nodo puo essere annotato
   con zero o più _attributi_.

** Atributi
   Un attributo è una coppia (*nome,valore*) che rappresenta una qualunque informazione associata 
   ad un nodo di un albero sintattico.

*** Attributi sintetizzati
    Si dice sintetizzato se il valore del attributo dipende da quello di attributi dei figli di
    del nodo.

**** Esempio
     avendo un nodo A con l'argomento sintattico S, e con _n_ figli.
     A → X₁, X₂ ... Xₙ    A.s = F(X₁ .a₁, X₂. a₂, Xₙ. aₙ)

*** Attributi ereditato
    si dice ereditato  se il valore del attributo dipende da quello di attributi 
    del padre _e dei fratelli di N_.
    
* 5.2 Schemi di traduzione (SDT)
  È una variante delle SDD in cui si rende explicito _l'ordine di volutazione_ degli 
  attributi.

  Uno *schema di traduziona* o SDT è una grammatica in cui le produzioni sono arrichite da 
  _frammenti di codice_ detti *azioni semantiche* che sono eseguite nel momento in cui tutti i simboli
  alla loro sinistra sono stati riconosciuti.

** Esempi

|------------+----------------------+----------------------------------------------------------------------------------------------------------------|
| produzione | produzione + Azioni  | Desscrizione                                                                                                   |
|------------+----------------------+----------------------------------------------------------------------------------------------------------------|
| A → BC     | A → BC{code}         | code eseguito dopo il riconoscimento di B e C.                                                                 |
| A → BC     | A → B{code}C         | code eseguito dopo il riconosciemnto di B ma prima del riconoscimento di C.                                    |
| A → BC     | A → {code1}BC{code2} | code 1 eseguito subito dopo la riscrittura di A e prima del riconoscimento di B. code 2 dopo il riconoscere C. |
| A → ϵ       | A → {code}           | code eseguito subito dopo la riscrittura di A.                                                                 |
|------------+----------------------+----------------------------------------------------------------------------------------------------------------|

** Differenze tra regole e azioni semantiche

|-----------------------------------------+---------------------------------------------------|
| SDD                                     | SDT                                               |
|-----------------------------------------+---------------------------------------------------|
| specificano come determinare il valore  | _Solitamente_ specificano come determinare          |
| degli attributi.                        | il valore degli attributi, ma possono contenere   |
|                                         | _codice arbitrario_ (stampe,metodi,etc)             |
|-----------------------------------------+---------------------------------------------------|
| Sono valutate in un _ordine implicito_    | Sono eseguite in un ordine esplicito determinato  |
| determinato dal grafo delle dipendenze. | dalla loro posizione nel corpo delle porduzioni.  |
|-----------------------------------------+---------------------------------------------------|
| Poiche valutate in un ordine arbitrario | Poiche eseguite da sinistra verso destra, possono |
| in generale richiedono la costruzione   | essere integrate al parsing ricorsivo discendente |
| dell'albero sintattico annotato.        | senza richiedere la costruzione dell'albero       |
|                                         | sintattico annotato.                              |
|-----------------------------------------+---------------------------------------------------|

** Algoritmo
   Data una SDD L-attribuita, si può ottenere una SDT corrispondente nel modo seguente. 
   Per ogni produzione A → X₁, X₂... Xₙ della grammatica:

   Subito prima di Xᵢ, aggiungere un’azione semantica che calcola il valore degli
   attributi ereditati di . Nota: in una SDD L-attribuita, questi attributi possono 
   dipendere solo da attributi ereditati di *A* ed attributi di X₁, … ,X_{i-1}.

   In fondo alla produzione, aggiungere un’azione semantica che calcola il valore 
   degli attributi sintetizzati di *A*.

* 5.3 Codice intermedio (assembly inside JVM)
** Java virtual Machine (JVM)
   interprete in grado di eseguire *bytecode* con le caratteristiche:
   
   - Macchina virtuale basata su *pila*.
   - Istruzioni di basso ed alto livello.
   - Garbage Collector.

*** Uso tipico della JVM

              javac            java 
    | .java | ----> | .class | ----> | risultato |

*** Uso in questo corso

             compilatore        jasmin              java
    | .lft | ----------> | .j | ------> | .class | ------> | risultato |
    
    - Il file .j contiene bytecode  JVM in _formato mnemonico_ (facile da produrre/leggere).
    - Il file .class contiene bytecode JVM in _formato binario_.
    - Usiamo _Jasmin_ per tradurre il bytecode dal formato mnemonico a quello binario.

** Componenti della JVM
*** area metodi
    Contiene che contiene il _bytecode_ corrispondenteai metodi di tutte le classi
    usate da un'applicazione.

*** insieme di registri
    È un insieme di registri  che contengono informazione essenziali sullo stato
    della macchina virtuale. Tra tutti, il _program counter_ contiene l'indirizzo della
    prossima istruzione da eseguire.

*** pila di frame
    un frame per ogni metodo di esecuzione. A sua volta ogni frame è composto da:
    
**** pila degli operandi
     usata per la volutazione di _risultati temporanei_.
**** array di variabili
     usato per la memorizzazione delle _variabili locali_ degli _argomenti del metodo_.
**** heap
     in cui vengono allocati gli oggetti.

** Struttura di un frame della JVM
   il frame del metodo in esecuzione contiene:
   - argomenti e variabili locali (indirizzati a partire da 0)
   - pila degli operandi (cresce/cala durante l'esecuzione del metodo)
*** Esempio
#+BEGIN_SRC java
static void m( int a, boolean b){
    int x, y;
    char z;

    ... 5 * x ....
}
#+END_SRC

per il metodo m, ci da il seguente frame:
 
|------+---------+--------|
| Nome | Slot n. | Valore |
|------+---------+--------|
| a    |       0 | 42     |
| b    |       1 | true   |
|------+---------+--------|
| x    |       2 | 7      |
| y    |       3 | 23     |
| z    |       4 | 'c'    |
|------+---------+--------|
| ---  |     --- | 5      |
| ---  |     --- | 7      |
|      |         | .      |
|      |         | .      |
|      |         | .      |
|------+---------+--------|

** Gestione della pila degli operandi

|------------+-------+-------+---------------------------------------|
| istruzione | prima | dopo  | descrizione                           |
|------------+-------+-------+---------------------------------------|
| ldc _v_      |       | v     | carica _v_ sulla pila                   |
| iload _&x_   |       | v     | cariaca il valore di _x_ sulla pila     |
| istore _&x_  | v     |       | assegna _v_ a _x_                         |
| pop        | v     |       | rimuove il valore in cima alla pila   |
| dup        | v     | v v   | duplica il valore in cima alla pila   |
| swap       | v1 v2 | v2 v1 | scambia i due valor in cima alla pila |
|------------+-------+-------+---------------------------------------|

le istruzioni  _iload_ e _istore_ hanno come argomento l'indirizzo e non il
nome della variabile _x_ nel frame del metodo corrente

** operazioni aritmetiche e su bit

|------------+-------+------+-----------------------------|
| istruzione | prima | dopo | descrizione                 |
|------------+-------+------+-----------------------------|
| ineg       | v     | v    | negazione                   |
| iadd       | v1 v2 | v    | somma v1+v2                 |
| isub       | v1 v2 | v    | sottrazione v1 - v2         |
| imul       | v1 v2 | v    | moltiplicazione v1xv2       |
| idiv       | v1 v2 | v    | divisione v1/v2             |
| irem       | v1 v2 | v    | resto della divisione v1/v2 |
| iand       | v1 v2 | v    | congiunzione bit a bit      |
| ior        | v1 v2 | v    | disgiunzione bit a bit      |
|------------+-------+------+-----------------------------|

sempre il v₂ sara il valore alla cima della pilla.

** Gestione degli array

|-------------+-------+------+----------------------------|
| istruzione  | prima | dopo | descrizione                |
|-------------+-------+------+----------------------------|
| newarray    | n     | a    | cra un array di n elementi |
| arraylength | a     | n    | dimensione dell'array a    |
| iaload      | a i   | v    | carica a[i] sulla pila     |
| iastore     | a i v |      | assegna v ad a[i]          |
|-------------+-------+------+----------------------------|

_a_ è un riferimento all'array nell'heap.

** Controllo di flusso

|----------------+---------+------+---------------------------------|
| istruzione     | prima   | dopo | descrizione                     |
|----------------+---------+------+---------------------------------|
| goto l         |         |      | salta a l                       |
| if_ icmpeq l   | v1 v2   |      | salta a l se v1 = v2            |
| if_ icmpne l   | v1 v2   |      | salta a l se v1 ≠ v2            |
| if_ icmple l   | v1 v2   |      | salta a l se v1 ≤ v2            |
| if_ icmpge l   | v1 v2   |      | salta a l se v1 ≥ v2            |
| if_ icmplt l   | v1 v2   |      | salta a l se v1 < v2            |
| if_ icmpgt l   | v1 v2   |      | salta a l se v1 > v2            |
| invokestatic m | v1...vn | v?   | invoca m(v1,...,vn)             |
| return         |         |      | termina il metodo               |
| ireturn        | v       |      | termina il metodo restituendo v |
|----------------+---------+------+---------------------------------|

* 5.4 Traduzione di espressioni aritmetiche
  Definiamo SDD e SDT per la traduzione di espressioni aritmetiche.
** Grammatica delle espressioni aritmetiche

|---------------+------------------------------|
| produzioni    | descrizione                  |
|---------------+------------------------------|
| E \to E1 + E2 | somma                        |
| E \to E1 - E2 | Sottrazione                  |
| E \to E1 * E2 | moltiplicazione              |
| E \to E1 / E2 | divisione intera             |
| E \to E1 % E2 | resto della divisione intera |
| E \to (E1)    | stesso valores di E1         |
| E \to n       | costante                     |
| E \to x       | variabile                    |
|---------------+------------------------------|

** SDD per espresioni aritmetiche
   
|---------------+-----------------------------------|
| produzioni    | regole semantiche                 |
|---------------+-----------------------------------|
| E → n         | E.code = ldc n.v                  |
| E → x         | E.code = iload &x                 |
| E → E1 + E2   | E.code = E1.code / E2.code / iadd |
| E → (E1)      | E.code = E1.code                  |
|---------------+-----------------------------------|

E.code = codice che calcola il valore di E e lo lascia
in cima alla pila.

** SDT per la grammatica ambigua 
*** SDT con accumulo del codice

|-------------+--------------------------------------|
| produzioni  | Azioni semantiche                    |
|-------------+--------------------------------------|
| E → E1 + E2 | {E.code = E1.code / E2.code / iadd}  |
| E → E1 - E2 | {E.code =  E1.code / E2.code / isub} |
| E → E1 * E2 | {E.code = E1.code / E2.code / imul}  |
| E → E1 / E2 | {E.code = E1.code / E2.code / idiv}  |
| E → E1 % E2 | {E.code = E1.code / E2.code / irem}  |
| E → (E1)    | {E.code = E1.code}                   |
| E → n       | {E.code = ldc n.v}                   |
| E → x       | {e.code = iload &x}                  |
|-------------+--------------------------------------|

*** SDT "on the fly"

|-------------+-------------------|
| produzioni  | Azioni semantiche |
|-------------+-------------------|
| E → E1 + E2 | {emit(iadd)}      |
| E → E1 - E2 | {emit(isub)}      |
| E → E1 * E2 | {emit(imul)}      |
| E → E1 / E2 | {emit(idiv)}      |
| E → E1 % E2 | {emit(irem)}      |
| E → (E1)    |                   |
| E → n       | {emit(ldc n.v)}   |
| E → x       | {emit(iload &x)}  |
|-------------+-------------------|

* 5.5 Traduzione di espresioni logiche

** espressioni logiche con cortocircuito

|--------------+---------------------|
| Produzioni   | Descrizione         |
|--------------+---------------------|
| B → true     | Sempre vero         |
| B → false    | Sempre false        |
| B → E1 R E2  | Confronto           |
| B → B1 && B2 | congiunzione logica |
| B → B1 \\ B2 | disgiunzione logica |
| B → !B1      | negazione logica    |
| B → (B1)     | Stesso valore di B1 |
|--------------+---------------------|

|------------+-----------------|
| Produzioni | Descrizione     |
|------------+-----------------|
| R \to ==   | Uguale          |
| R \to !=   | Diverso         |
| R \to <    | minore          |
| R \to >    | maggiore        |
| R \to ≤    | minore o uguale |
| R \to ≥    | maggiore o ugu  |
|------------+-----------------|

*** Attributi
    - _B.true_ = etichetta a cui saltare se B è vera(ereditato)
    - _B.false_ = etichetta a cui saltare se B è falsa(ereditato)
    - B.code = codice che salta a _B.true_ se B è vera o a _B.false_

** Costanti e relazioni

|-------------+------------------------------------------------------------|
| produzioni  | Regole Semantiche                                          |
|-------------+------------------------------------------------------------|
| B \to true    | B.code= goto B.true                                        |
| B \to false   | B.code= goto B.false                                       |
| B \to E1 R E2 | B.code= E1.code \ E2.code \ if icmpR B.true \ goto B.false |
|-------------+------------------------------------------------------------|


** Congiunzione e negazione

|--------------+------------------------------------|
| produzioni   | Regole Semantiche                  |
|--------------+------------------------------------|
| B → B1 && B2 | B1.true = newlabel()               |
|              | B1.false= B.false                  |
|              | B2.true = B.true                   |
|              | B2.false= B.false                  |
|              | B.code= B1.code \ B1.true: B2.code |
| B → !B1      | B1.true = B.false                  |
|              | B1.false= B.true                   |
|              | B.code = B1.code                   |
|--------------+------------------------------------|

** Esempi 
*** Codice per x < y
#+BEGIN_SRC C
iload &x;
iload &y;
if_complt B.true
goto B.false
#+END_SRC
*** codice per 0 <=x && x<5
#+BEGIN_SRC C
   ldc 0;
   iload &x;
   if_icmple L1;
   goto B.false;
   L1: iload &x;
   ldc 5;
   if_icmplt B.true
   goto B.false
#+END_SRC
in questo esempio abbiamo creato una nuova etichetta con
il nome _L1_ per condizionare il _goto_.
* 5.6 Traduzione di comandi
